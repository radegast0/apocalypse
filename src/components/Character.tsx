/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, {
  useRef,
  useEffect,
  useState,
  forwardRef,
  useImperativeHandle,
} from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import type { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    Cube005: THREE.SkinnedMesh;
    Cube005_1: THREE.SkinnedMesh;
    Cube005_2: THREE.SkinnedMesh;
    Cube005_3: THREE.SkinnedMesh;
    Cube005_4: THREE.SkinnedMesh;
    Hips: THREE.Bone;
  };
  materials: {
    ["Material.021"]: THREE.MeshPhysicalMaterial;
    ["Material.022"]: THREE.MeshPhysicalMaterial;
    ["Material.023"]: THREE.MeshPhysicalMaterial;
    ["Material.024"]: THREE.MeshPhysicalMaterial;
    ["Material.025"]: THREE.MeshPhysicalMaterial;
  };
};

type ActionName =
  | "idle"
  | "running"
  | "equip"
  | "attack"
  | "idleReady"
  | "unequip";

const Character = forwardRef<THREE.Group, React.ComponentProps<"group">>(
  function Character(props, ref) {
    const group = useRef<THREE.Group>(null);
    useImperativeHandle(ref, () => group.current as THREE.Group);
    const { nodes, materials, animations } = useGLTF(
      "/animated.glb"
    ) as unknown as GLTFResult;
    const { actions } = useAnimations(animations, group);
    const [currentAction, setCurrentAction] = useState<ActionName>("idle");
    const prevActionRef = useRef<ActionName>("idle");

    // Play the selected animation with fade in/out
    useEffect(() => {
      if (!actions[currentAction]) return;

      const prevAction = actions[prevActionRef.current];
      const newAction = actions[currentAction];

      if (prevAction && prevActionRef.current !== currentAction) {
        prevAction.fadeOut(0.5);
      }

      if (currentAction === "equip" || currentAction === "unequip") {
        newAction.clampWhenFinished = true;
        newAction.loop = THREE.LoopOnce;
      }

      newAction
        .reset()
        .setEffectiveTimeScale(1)
        .setEffectiveWeight(1)
        .fadeIn(0.5)
        .play();

      if (actions.equip && actions.unequip) {
        actions.equip.getMixer().addEventListener("finished", () => {
          setCurrentAction("idle");
        });
        actions.unequip.getMixer().addEventListener("finished", () => {
          setCurrentAction("idle");
        });
      }

      prevActionRef.current = currentAction;
    }, [actions, currentAction]);

    // Keyboard controls with toggle behavior
    useEffect(() => {
      function handleKeyDown(e: KeyboardEvent) {
        if (e.repeat) return;
        let nextAction: ActionName | null = null;
        if (e.key === "w" || e.key === "W") nextAction = "idle";
        else if (e.key === "r" || e.key === "R") nextAction = "running";
        else if (e.key === "e" || e.key === "E") nextAction = "equip";
        else if (e.key === "a" || e.key === "A") nextAction = "attack";
        else if (e.key === "d" || e.key === "D") nextAction = "idleReady";
        else if (e.key === "q" || e.key === "Q") nextAction = "unequip";

        if (nextAction) {
          if (nextAction === "equip" || nextAction === "unequip") {
            setCurrentAction(nextAction);
          } else {
            setCurrentAction((current) =>
              current === nextAction ? "idle" : nextAction
            );
          }
        }
      }
      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, []); // Empty dependency array ensures this effect runs only once

    return (
      <>
        <group ref={group} {...props} dispose={null}>
          <group name="Scene">
            <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
              <group name="merged">
                <skinnedMesh
                  castShadow
                  name="Cube005"
                  geometry={nodes.Cube005.geometry}
                  material={materials["Material.021"]}
                  skeleton={nodes.Cube005.skeleton}
                />
                <skinnedMesh
                  castShadow
                  name="Cube005_1"
                  geometry={nodes.Cube005_1.geometry}
                  material={materials["Material.022"]}
                  skeleton={nodes.Cube005_1.skeleton}
                />
                <skinnedMesh
                  castShadow
                  name="Cube005_2"
                  geometry={nodes.Cube005_2.geometry}
                  material={materials["Material.023"]}
                  skeleton={nodes.Cube005_2.skeleton}
                />
                <skinnedMesh
                  castShadow
                  name="Cube005_3"
                  geometry={nodes.Cube005_3.geometry}
                  material={materials["Material.024"]}
                  skeleton={nodes.Cube005_3.skeleton}
                />
                <skinnedMesh
                  castShadow
                  name="Cube005_4"
                  geometry={nodes.Cube005_4.geometry}
                  material={materials["Material.025"]}
                  skeleton={nodes.Cube005_4.skeleton}
                />
              </group>
              <primitive object={nodes.Hips} />
            </group>
          </group>
        </group>
      </>
    );
  }
);

export default Character;

useGLTF.preload("/animated.glb");
