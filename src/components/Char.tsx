/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useRef, useEffect, useState, type JSX } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import type { GLTF } from "three/examples/jsm/Addons.js";

type GLTFResult = GLTF & {
  nodes: {
    Cube001: THREE.SkinnedMesh;
    Cube001_1: THREE.SkinnedMesh;
    Cube001_2: THREE.SkinnedMesh;
    Cube001_3: THREE.SkinnedMesh;
    Cube001_4: THREE.SkinnedMesh;
    pCylinder15_standardSurface5_0001: THREE.Mesh;
    pCylinder15_standardSurface5_0001_1: THREE.Mesh;
    pCylinder15_standardSurface5_0001_2: THREE.Mesh;
    pCylinder15_standardSurface5_0001_3: THREE.Mesh;
    pCylinder15_standardSurface5_0001_4: THREE.Mesh;
    pCylinder15_standardSurface5_0001_5: THREE.Mesh;
    pCylinder15_standardSurface5_0001_6: THREE.Mesh;
    pCylinder15_standardSurface5_0001_7: THREE.Mesh;
    pCylinder15_standardSurface5_0001_8: THREE.Mesh;
    pCylinder15_standardSurface5_0001_9: THREE.Mesh;
    pCylinder15_standardSurface5_0001_10: THREE.Mesh;
    pCylinder15_standardSurface5_0001_11: THREE.Mesh;
    pCylinder15_standardSurface5_0: THREE.Mesh;
    pCylinder15_standardSurface5_0_1: THREE.Mesh;
    pCylinder15_standardSurface5_0_2: THREE.Mesh;
    pCylinder15_standardSurface5_0_3: THREE.Mesh;
    pCylinder15_standardSurface5_0_4: THREE.Mesh;
    pCylinder15_standardSurface5_0_5: THREE.Mesh;
    pCylinder15_standardSurface5_0_6: THREE.Mesh;
    pCylinder15_standardSurface5_0_7: THREE.Mesh;
    pCylinder15_standardSurface5_0_8: THREE.Mesh;
    pCylinder15_standardSurface5_0_9: THREE.Mesh;
    pCylinder15_standardSurface5_0_10: THREE.Mesh;
    pCylinder15_standardSurface5_0_11: THREE.Mesh;
    Hips: THREE.Bone;
  };
  materials: {
    ["Material.021"]: THREE.MeshPhysicalMaterial;
    ["Material.022"]: THREE.MeshPhysicalMaterial;
    ["Material.023"]: THREE.MeshPhysicalMaterial;
    ["Material.024"]: THREE.MeshPhysicalMaterial;
    ["Material.025"]: THREE.MeshPhysicalMaterial;
    standardSurface5: THREE.MeshStandardMaterial;
    standardSurface8: THREE.MeshStandardMaterial;
    standardSurface6: THREE.MeshStandardMaterial;
    standardSurface18: THREE.MeshStandardMaterial;
    standardSurface22: THREE.MeshStandardMaterial;
    standardSurface4: THREE.MeshStandardMaterial;
    standardSurface19: THREE.MeshStandardMaterial;
    standardSurface3: THREE.MeshStandardMaterial;
    standardSurface11: THREE.MeshStandardMaterial;
    standardSurface15: THREE.MeshStandardMaterial;
    standardSurface7: THREE.MeshStandardMaterial;
    standardSurface12: THREE.MeshStandardMaterial;
  };
};

type ActionName =
  | "attack"
  | "equip"
  | "idle"
  | "idleReady"
  | "running"
  | "unequip";
type GLTFActions = Record<ActionName, THREE.AnimationAction>;

export function Char(props: JSX.IntrinsicElements["group"]) {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF(
    "/test.glb"
  ) as unknown as GLTFResult;
  const { actions } = useAnimations(animations, group);
  const acts = actions as unknown as GLTFActions;

  const [currentAction, setCurrentAction] = useState<ActionName>("idle");
  const prevActionRef = useRef<ActionName>("idle");

  // Track whether the weapon is equipped (hand) or on the back
  const [equipped, setEquipped] = useState(false);

  // Refs to the two axe objects inside the skeleton hierarchy
  const guitarBackRef = useRef<THREE.Object3D | null>(null);
  const guitarHandRef = useRef<THREE.Object3D | null>(null);

  // Find the objects named "guitarBack" and "guitarHand" inside the primitive
  useEffect(() => {
    const root = group.current;
    if (!root) return;
    root.traverse((obj) => {
      if (obj.name === "guitarBack") guitarBackRef.current = obj;
      if (obj.name === "guitarHand") guitarHandRef.current = obj;
      //   const m = obj as THREE.Mesh & { isSkinnedMesh?: boolean };
      //   if ((m as any).isMesh || (m as any).isSkinnedMesh) {
      //     m.frustumCulled = false;
      //   }
    });
    // Initialize visibility
    if (guitarBackRef.current) guitarBackRef.current.visible = !equipped;
    if (guitarHandRef.current) guitarHandRef.current.visible = equipped;
  }, []);

  // Update visibility when equipped state changes
  useEffect(() => {
    if (guitarBackRef.current) guitarBackRef.current.visible = !equipped;
    if (guitarHandRef.current) guitarHandRef.current.visible = equipped;
  }, [equipped]);

  // Play/fade between actions and setup one-shot config for equip/unequip
  useEffect(() => {
    if (!acts || !acts[currentAction]) return;

    const prevAction = acts[prevActionRef.current];
    const newAction = acts[currentAction];

    if (prevAction && prevActionRef.current !== currentAction) {
      prevAction.fadeOut(0.5);
    }

    if (currentAction === "equip" || currentAction === "unequip") {
      newAction.clampWhenFinished = true;
      newAction.loop = THREE.LoopOnce;
    } else {
      newAction.clampWhenFinished = false;
      newAction.loop = THREE.LoopRepeat;
    }

    newAction
      .reset()
      .setEffectiveTimeScale(1)
      .setEffectiveWeight(1)
      .fadeIn(0.5)
      .play();

    prevActionRef.current = currentAction;
  }, [actions, currentAction]);

  // Listen once for animation finish to toggle equipped state
  useEffect(() => {
    const mixer = acts?.equip?.getMixer() ?? acts?.unequip?.getMixer() ?? null;
    if (!mixer) return;

    const onFinished = (e: any) => {
      const name: string | undefined = e?.action?.getClip?.().name;
      if (name === "equip") {
        setEquipped(true);
        setCurrentAction("idle");
      } else if (name === "unequip") {
        setEquipped(false);
        setCurrentAction("idle");
      }
    };

    mixer.addEventListener("finished", onFinished);
    return () => {
      mixer.removeEventListener("finished", onFinished);
    };
  }, [acts?.equip, acts?.unequip]);

  // Simple keyboard controls
  useEffect(() => {
    function handleKeyDown(e: KeyboardEvent) {
      if (e.repeat) return;
      let nextAction: ActionName | null = null;
      if (e.key === "w" || e.key === "W") nextAction = "idle";
      else if (e.key === "r" || e.key === "R") nextAction = "running";
      else if (e.key === "e" || e.key === "E") nextAction = "equip";
      else if (e.key === "a" || e.key === "A") nextAction = "attack";
      else if (e.key === "d" || e.key === "D") nextAction = "idleReady";
      else if (e.key === "q" || e.key === "Q") nextAction = "unequip";

      if (nextAction) {
        if (nextAction === "equip" || nextAction === "unequip") {
          setCurrentAction(nextAction);
        } else {
          setCurrentAction((current) =>
            current === nextAction ? "idle" : nextAction
          );
        }
      }
    }
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group
          name="Armature001"
          position={[-2, 0, 0]}
          rotation={[Math.PI / 2, 0, 0]}
          scale={0.01}
        >
          <group name="merged001">
            <skinnedMesh
              name="Cube001"
              geometry={nodes.Cube001.geometry}
              material={materials["Material.021"]}
              skeleton={nodes.Cube001.skeleton}
              frustumCulled={false}
            />
            <skinnedMesh
              name="Cube001_1"
              geometry={nodes.Cube001_1.geometry}
              material={materials["Material.022"]}
              skeleton={nodes.Cube001_1.skeleton}
              frustumCulled={false}
            />
            <skinnedMesh
              name="Cube001_2"
              geometry={nodes.Cube001_2.geometry}
              material={materials["Material.023"]}
              skeleton={nodes.Cube001_2.skeleton}
              frustumCulled={false}
            />
            <skinnedMesh
              name="Cube001_3"
              geometry={nodes.Cube001_3.geometry}
              material={materials["Material.024"]}
              skeleton={nodes.Cube001_3.skeleton}
              frustumCulled={false}
            />
            <skinnedMesh
              name="Cube001_4"
              geometry={nodes.Cube001_4.geometry}
              material={materials["Material.025"]}
              skeleton={nodes.Cube001_4.skeleton}
              frustumCulled={false}
            />
          </group>
          <primitive object={nodes.Hips} />
        </group>
      </group>
    </group>
  );
}
